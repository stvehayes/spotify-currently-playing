{"ast":null,"code":"import { onNextFrame, defaultTimestep } from './on-next-frame.mjs';\nimport { createRenderStep } from './create-render-step.mjs';\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst frame = {\n  delta: 0,\n  timestamp: 0\n};\nconst stepsOrder = [\"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nconst steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n\n  acc[key] = function (process) {\n    let keepAlive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let immediate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!runNextFrame) startLoop();\n    return step.schedule(process, keepAlive, immediate);\n  };\n\n  return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n\n  return acc;\n}, {});\n\nconst processStep = stepId => steps[stepId].process(frame);\n\nconst processFrame = timestamp => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\n\nconst startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing) onNextFrame(processFrame);\n};\n\nconst getFrameData = () => frame;\n\nexport default sync;\nexport { cancelSync, flushSync, getFrameData };","map":null,"metadata":{},"sourceType":"module"}