{"ast":null,"code":"import { __assign } from 'tslib';\nimport sync, { getFrameData } from 'framesync';\nimport { mix, progress, linear, mixColor, circOut } from 'popmotion';\nimport { animate } from '../../../animation/animate.js';\nimport { getValueTransition } from '../../../animation/utils/transitions.js';\nimport { motionValue } from '../../../value/index.js';\n\nfunction createCrossfader() {\n  /**\n   * The current state of the crossfade as a value between 0 and 1\n   */\n  var progress = motionValue(1);\n  var options = {\n    lead: undefined,\n    follow: undefined,\n    crossfadeOpacity: false,\n    preserveFollowOpacity: false\n  };\n\n  var prevOptions = __assign({}, options);\n\n  var leadState = {};\n  var followState = {};\n  /**\n   *\n   */\n\n  var isActive = false;\n  /**\n   *\n   */\n\n  var finalCrossfadeFrame = null;\n  /**\n   * Framestamp of the last frame we updated values at.\n   */\n\n  var prevUpdate = 0;\n\n  function startCrossfadeAnimation(target, transition) {\n    var lead = options.lead,\n        follow = options.follow;\n    isActive = true;\n    finalCrossfadeFrame = null;\n    var hasUpdated = false;\n\n    var onUpdate = function () {\n      hasUpdated = true;\n      lead && lead.scheduleRender();\n      follow && follow.scheduleRender();\n    };\n\n    var onComplete = function () {\n      isActive = false;\n      /**\n       * If the crossfade animation is no longer active, flag a frame\n       * that we're still allowed to crossfade\n       */\n\n      finalCrossfadeFrame = getFrameData().timestamp;\n    };\n\n    transition = transition && getValueTransition(transition, \"crossfade\");\n    return animate(progress, target, __assign(__assign({}, transition), {\n      onUpdate: onUpdate,\n      onComplete: function () {\n        if (!hasUpdated) {\n          progress.set(target);\n          /**\n           * If we never ran an update, for instance if this was an instant transition, fire a\n           * simulated final frame to ensure the crossfade gets applied correctly.\n           */\n\n          sync.read(onComplete);\n        } else {\n          onComplete();\n        }\n\n        onUpdate();\n      }\n    }));\n  }\n\n  function updateCrossfade() {\n    var _a, _b;\n    /**\n     * We only want to compute the crossfade once per frame, so we\n     * compare the previous update framestamp with the current frame\n     * and early return if they're the same.\n     */\n\n\n    var timestamp = getFrameData().timestamp;\n    var lead = options.lead,\n        follow = options.follow;\n    if (timestamp === prevUpdate || !lead) return;\n    prevUpdate = timestamp;\n    /**\n     * Merge each component's latest values into our crossfaded state\n     * before crossfading.\n     */\n\n    var latestLeadValues = lead.getLatestValues();\n    Object.assign(leadState, latestLeadValues);\n    var latestFollowValues = follow ? follow.getLatestValues() : options.prevValues;\n    Object.assign(followState, latestFollowValues);\n    var p = progress.get();\n    /**\n     * Crossfade the opacity between the two components. This will result\n     * in a different opacity for each component.\n     */\n\n    var leadTargetOpacity = (_a = latestLeadValues.opacity) !== null && _a !== void 0 ? _a : 1;\n    var followTargetOpacity = (_b = latestFollowValues === null || latestFollowValues === void 0 ? void 0 : latestFollowValues.opacity) !== null && _b !== void 0 ? _b : 1;\n\n    if (options.crossfadeOpacity && follow) {\n      leadState.opacity = mix(\n      /**\n       * If the follow child has been completely hidden we animate\n       * this opacity from its previous opacity, but otherwise from completely transparent.\n       */\n      follow.isVisible !== false ? 0 : followTargetOpacity, leadTargetOpacity, easeCrossfadeIn(p));\n      followState.opacity = options.preserveFollowOpacity ? followTargetOpacity : mix(followTargetOpacity, 0, easeCrossfadeOut(p));\n    } else if (!follow) {\n      leadState.opacity = mix(followTargetOpacity, leadTargetOpacity, p);\n    }\n\n    mixValues(leadState, followState, latestLeadValues, latestFollowValues || {}, Boolean(follow), p);\n  }\n\n  return {\n    isActive: function () {\n      return leadState && (isActive || getFrameData().timestamp === finalCrossfadeFrame);\n    },\n    fromLead: function (transition) {\n      return startCrossfadeAnimation(0, transition);\n    },\n    toLead: function (transition) {\n      var initialProgress = 0;\n\n      if (!options.prevValues && !options.follow) {\n        /**\n         * If we're not coming from anywhere, start at the end of the animation.\n         */\n        initialProgress = 1;\n      } else if (prevOptions.lead === options.follow && prevOptions.follow === options.lead) {\n        /**\n         * If we're swapping follow/lead we can reverse the progress\n         */\n        initialProgress = 1 - progress.get();\n      }\n\n      progress.set(initialProgress);\n      return startCrossfadeAnimation(1, transition);\n    },\n    reset: function () {\n      return progress.set(1);\n    },\n    stop: function () {\n      return progress.stop();\n    },\n    getCrossfadeState: function (element) {\n      updateCrossfade();\n\n      if (element === options.lead) {\n        return leadState;\n      } else if (element === options.follow) {\n        return followState;\n      }\n    },\n    setOptions: function (newOptions) {\n      prevOptions = options;\n      options = newOptions;\n      leadState = {};\n      followState = {};\n    },\n    getLatestValues: function () {\n      return leadState;\n    }\n  };\n}\n\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\n\nfunction compress(min, max, easing) {\n  return function (p) {\n    // Could replace ifs with clamp\n    if (p < min) return 0;\n    if (p > max) return 1;\n    return easing(progress(min, max, p));\n  };\n}\n\nvar borders = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"];\nvar numBorders = borders.length;\n\nfunction mixValues(leadState, followState, latestLeadValues, latestFollowValues, hasFollowElement, p) {\n  /**\n   * Mix border radius\n   */\n  for (var i = 0; i < numBorders; i++) {\n    var borderLabel = \"border\" + borders[i] + \"Radius\";\n    var followRadius = getRadius(latestFollowValues, borderLabel);\n    var leadRadius = getRadius(latestLeadValues, borderLabel);\n    if (followRadius === undefined && leadRadius === undefined) continue;\n    followRadius || (followRadius = 0);\n    leadRadius || (leadRadius = 0);\n    /**\n     * Currently we're only crossfading between numerical border radius.\n     * It would be possible to crossfade between percentages for a little\n     * extra bundle size.\n     */\n\n    if (typeof followRadius === \"number\" && typeof leadRadius === \"number\") {\n      var radius = Math.max(mix(followRadius, leadRadius, p), 0);\n      leadState[borderLabel] = followState[borderLabel] = radius;\n    }\n  }\n  /**\n   * Mix rotation\n   */\n\n\n  if (latestFollowValues.rotate || latestLeadValues.rotate) {\n    var rotate = mix(latestFollowValues.rotate || 0, latestLeadValues.rotate || 0, p);\n    leadState.rotate = followState.rotate = rotate;\n  }\n  /**\n   * We only want to mix the background color if there's a follow element\n   * that we're not crossfading opacity between. For instance with switch\n   * AnimateSharedLayout animations, this helps the illusion of a continuous\n   * element being animated but also cuts down on the number of paints triggered\n   * for elements where opacity is doing that work for us.\n   */\n\n\n  if (!hasFollowElement && latestLeadValues.backgroundColor && latestFollowValues.backgroundColor) {\n    /**\n     * This isn't ideal performance-wise as mixColor is creating a new function every frame.\n     * We could probably create a mixer that runs at the start of the animation but\n     * the idea behind the crossfader is that it runs dynamically between two potentially\n     * changing targets (ie opacity or borderRadius may be animating independently via variants)\n     */\n    leadState.backgroundColor = followState.backgroundColor = mixColor(latestFollowValues.backgroundColor, latestLeadValues.backgroundColor)(p);\n  }\n}\n\nfunction getRadius(values, radiusName) {\n  var _a;\n\n  return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n\nexport { createCrossfader };","map":null,"metadata":{},"sourceType":"module"}