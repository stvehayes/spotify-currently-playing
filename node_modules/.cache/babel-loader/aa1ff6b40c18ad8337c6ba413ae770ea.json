{"ast":null,"code":"import { warning } from 'hey-listen';\nimport { clamp } from '../../utils/clamp.js';\nvar safeMin = 0.001;\nvar minDuration = 0.01;\nvar maxDuration = 10.0;\nvar minDamping = 0.05;\nvar maxDamping = 1;\n\nfunction findSpring(_a) {\n  var _b = _a.duration,\n      duration = _b === void 0 ? 800 : _b,\n      _c = _a.bounce,\n      bounce = _c === void 0 ? 0.25 : _c,\n      _d = _a.velocity,\n      velocity = _d === void 0 ? 0 : _d,\n      _e = _a.mass,\n      mass = _e === void 0 ? 1 : _e;\n  var envelope;\n  var derivative;\n  warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n  var dampingRatio = 1 - bounce;\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration, duration / 1000);\n\n  if (dampingRatio < 1) {\n    envelope = function (undampedFreq) {\n      var exponentialDecay = undampedFreq * dampingRatio;\n      var delta = exponentialDecay * duration;\n      var a = exponentialDecay - velocity;\n      var b = calcAngularFreq(undampedFreq, dampingRatio);\n      var c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n\n    derivative = function (undampedFreq) {\n      var exponentialDecay = undampedFreq * dampingRatio;\n      var delta = exponentialDecay * duration;\n      var d = delta * velocity + velocity;\n      var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      var f = Math.exp(-delta);\n      var g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      var factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    envelope = function (undampedFreq) {\n      var a = Math.exp(-undampedFreq * duration);\n      var b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n\n    derivative = function (undampedFreq) {\n      var a = Math.exp(-undampedFreq * duration);\n      var b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n\n  var initialGuess = 5 / duration;\n  var undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1000;\n\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration: duration\n    };\n  } else {\n    var stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness: stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration: duration\n    };\n  }\n}\n\nvar rootIterations = 12;\n\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  var result = initialGuess;\n\n  for (var i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n\n  return result;\n}\n\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };","map":null,"metadata":{},"sourceType":"module"}