{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar tslib = require('tslib');\n\nvar heyListen = require('hey-listen');\n\nvar styleValueTypes = require('style-value-types');\n\nvar sync = require('framesync');\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar sync__default = /*#__PURE__*/_interopDefaultLegacy(sync);\n\nconst clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\n\nfunction findSpring(_ref) {\n  let {\n    duration = 800,\n    bounce = 0.25,\n    velocity = 0,\n    mass = 1\n  } = _ref;\n  let envelope;\n  let derivative;\n  heyListen.warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n  let dampingRatio = 1 - bounce;\n  dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n  duration = clamp(minDuration, maxDuration, duration / 1000);\n\n  if (dampingRatio < 1) {\n    envelope = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const a = exponentialDecay - velocity;\n      const b = calcAngularFreq(undampedFreq, dampingRatio);\n      const c = Math.exp(-delta);\n      return safeMin - a / b * c;\n    };\n\n    derivative = undampedFreq => {\n      const exponentialDecay = undampedFreq * dampingRatio;\n      const delta = exponentialDecay * duration;\n      const d = delta * velocity + velocity;\n      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n      const f = Math.exp(-delta);\n      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n      return factor * ((d - e) * f) / g;\n    };\n  } else {\n    envelope = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (undampedFreq - velocity) * duration + 1;\n      return -safeMin + a * b;\n    };\n\n    derivative = undampedFreq => {\n      const a = Math.exp(-undampedFreq * duration);\n      const b = (velocity - undampedFreq) * (duration * duration);\n      return a * b;\n    };\n  }\n\n  const initialGuess = 5 / duration;\n  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n  duration = duration * 1000;\n\n  if (isNaN(undampedFreq)) {\n    return {\n      stiffness: 100,\n      damping: 10,\n      duration\n    };\n  } else {\n    const stiffness = Math.pow(undampedFreq, 2) * mass;\n    return {\n      stiffness,\n      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n      duration\n    };\n  }\n}\n\nconst rootIterations = 12;\n\nfunction approximateRoot(envelope, derivative, initialGuess) {\n  let result = initialGuess;\n\n  for (let i = 1; i < rootIterations; i++) {\n    result = result - envelope(result) / derivative(result);\n  }\n\n  return result;\n}\n\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\n\nfunction isSpringType(options, keys) {\n  return keys.some(key => options[key] !== undefined);\n}\n\nfunction getSpringOptions(options) {\n  let springOptions = Object.assign({\n    velocity: 0.0,\n    stiffness: 100,\n    damping: 10,\n    mass: 1.0,\n    isResolvedFromDuration: false\n  }, options);\n\n  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {\n    const derived = findSpring(options);\n    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), {\n      velocity: 0.0,\n      mass: 1.0\n    });\n    springOptions.isResolvedFromDuration = true;\n  }\n\n  return springOptions;\n}\n\nfunction spring(_a) {\n  var {\n    from = 0.0,\n    to = 1.0,\n    restSpeed = 2,\n    restDelta\n  } = _a,\n      options = tslib.__rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n\n  const state = {\n    done: false,\n    value: from\n  };\n  let {\n    stiffness,\n    damping,\n    mass,\n    velocity,\n    duration,\n    isResolvedFromDuration\n  } = getSpringOptions(options);\n  let resolveSpring = zero;\n  let resolveVelocity = zero;\n\n  function createSpring() {\n    const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n    const initialDelta = to - from;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n\n    if (restDelta === undefined) {\n      restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n    }\n\n    if (dampingRatio < 1) {\n      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));\n      };\n\n      resolveVelocity = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t)) - envelope * (Math.cos(angularFreq * t) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t));\n      };\n    } else if (dampingRatio === 1) {\n      resolveSpring = t => to - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    } else {\n      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n\n      resolveSpring = t => {\n        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n        const freqForT = Math.min(dampedAngularFreq * t, 300);\n        return to - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;\n      };\n    }\n  }\n\n  createSpring();\n  return {\n    next: t => {\n      const current = resolveSpring(t);\n\n      if (!isResolvedFromDuration) {\n        const currentVelocity = resolveVelocity(t) * 1000;\n        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n        const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;\n      } else {\n        state.done = t >= duration;\n      }\n\n      state.value = state.done ? to : current;\n      return state;\n    },\n    flipTarget: () => {\n      velocity = -velocity;\n      [from, to] = [to, from];\n      createSpring();\n    }\n  };\n}\n\nspring.needsInterpolation = (a, b) => typeof a === \"string\" || typeof b === \"string\";\n\nconst zero = _t => 0;\n\nconst progress = (from, to, value) => {\n  const toFromDifference = to - from;\n  return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\nfunction hueToRgb(p, q, t) {\n  if (t < 0) t += 1;\n  if (t > 1) t -= 1;\n  if (t < 1 / 6) return p + (q - p) * 6 * t;\n  if (t < 1 / 2) return q;\n  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n  return p;\n}\n\nfunction hslaToRgba(_ref2) {\n  let {\n    hue,\n    saturation,\n    lightness,\n    alpha\n  } = _ref2;\n  hue /= 360;\n  saturation /= 100;\n  lightness /= 100;\n  let red = 0;\n  let green = 0;\n  let blue = 0;\n\n  if (!saturation) {\n    red = green = blue = lightness;\n  } else {\n    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;\n    const p = 2 * lightness - q;\n    red = hueToRgb(p, q, hue + 1 / 3);\n    green = hueToRgb(p, q, hue);\n    blue = hueToRgb(p, q, hue - 1 / 3);\n  }\n\n  return {\n    red: Math.round(red * 255),\n    green: Math.round(green * 255),\n    blue: Math.round(blue * 255),\n    alpha\n  };\n}\n\nconst mixLinearColor = (from, to, v) => {\n  const fromExpo = from * from;\n  const toExpo = to * to;\n  return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\n\nconst colorTypes = [styleValueTypes.hex, styleValueTypes.rgba, styleValueTypes.hsla];\n\nconst getColorType = v => colorTypes.find(type => type.test(v));\n\nconst notAnimatable = color => `'${color}' is not an animatable color. Use the equivalent color code instead.`;\n\nconst mixColor = (from, to) => {\n  let fromColorType = getColorType(from);\n  let toColorType = getColorType(to);\n  heyListen.invariant(!!fromColorType, notAnimatable(from));\n  heyListen.invariant(!!toColorType, notAnimatable(to));\n  let fromColor = fromColorType.parse(from);\n  let toColor = toColorType.parse(to);\n\n  if (fromColorType === styleValueTypes.hsla) {\n    fromColor = hslaToRgba(fromColor);\n    fromColorType = styleValueTypes.rgba;\n  }\n\n  if (toColorType === styleValueTypes.hsla) {\n    toColor = hslaToRgba(toColor);\n    toColorType = styleValueTypes.rgba;\n  }\n\n  const blended = Object.assign({}, fromColor);\n  return v => {\n    for (const key in blended) {\n      if (key !== \"alpha\") {\n        blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n      }\n    }\n\n    blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n    return fromColorType.transform(blended);\n  };\n};\n\nconst zeroPoint = {\n  x: 0,\n  y: 0,\n  z: 0\n};\n\nconst isNum = v => typeof v === 'number';\n\nconst combineFunctions = (a, b) => v => b(a(v));\n\nconst pipe = function () {\n  for (var _len = arguments.length, transformers = new Array(_len), _key = 0; _key < _len; _key++) {\n    transformers[_key] = arguments[_key];\n  }\n\n  return transformers.reduce(combineFunctions);\n};\n\nfunction getMixer(origin, target) {\n  if (isNum(origin)) {\n    return v => mix(origin, target, v);\n  } else if (styleValueTypes.color.test(origin)) {\n    return mixColor(origin, target);\n  } else {\n    return mixComplex(origin, target);\n  }\n}\n\nconst mixArray = (from, to) => {\n  const output = [...from];\n  const numValues = output.length;\n  const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n  return v => {\n    for (let i = 0; i < numValues; i++) {\n      output[i] = blendValue[i](v);\n    }\n\n    return output;\n  };\n};\n\nconst mixObject = (origin, target) => {\n  const output = Object.assign(Object.assign({}, origin), target);\n  const blendValue = {};\n\n  for (const key in output) {\n    if (origin[key] !== undefined && target[key] !== undefined) {\n      blendValue[key] = getMixer(origin[key], target[key]);\n    }\n  }\n\n  return v => {\n    for (const key in blendValue) {\n      output[key] = blendValue[key](v);\n    }\n\n    return output;\n  };\n};\n\nfunction analyse(value) {\n  const parsed = styleValueTypes.complex.parse(value);\n  const numValues = parsed.length;\n  let numNumbers = 0;\n  let numRGB = 0;\n  let numHSL = 0;\n\n  for (let i = 0; i < numValues; i++) {\n    if (numNumbers || typeof parsed[i] === \"number\") {\n      numNumbers++;\n    } else {\n      if (parsed[i].hue !== undefined) {\n        numHSL++;\n      } else {\n        numRGB++;\n      }\n    }\n  }\n\n  return {\n    parsed,\n    numNumbers,\n    numRGB,\n    numHSL\n  };\n}\n\nconst mixComplex = (origin, target) => {\n  const template = styleValueTypes.complex.createTransformer(target);\n  const originStats = analyse(origin);\n  const targetStats = analyse(target);\n  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;\n\n  if (canInterpolate) {\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n  } else {\n    heyListen.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n    return p => `${p > 0 ? target : origin}`;\n  }\n};\n\nconst mixNumber = (from, to) => p => mix(from, to, p);\n\nfunction detectMixerFactory(v) {\n  if (typeof v === 'number') {\n    return mixNumber;\n  } else if (typeof v === 'string') {\n    if (styleValueTypes.color.test(v)) {\n      return mixColor;\n    } else {\n      return mixComplex;\n    }\n  } else if (Array.isArray(v)) {\n    return mixArray;\n  } else if (typeof v === 'object') {\n    return mixObject;\n  }\n}\n\nfunction createMixers(output, ease, customMixer) {\n  const mixers = [];\n  const mixerFactory = customMixer || detectMixerFactory(output[0]);\n  const numMixers = output.length - 1;\n\n  for (let i = 0; i < numMixers; i++) {\n    let mixer = mixerFactory(output[i], output[i + 1]);\n\n    if (ease) {\n      const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n      mixer = pipe(easingFunction, mixer);\n    }\n\n    mixers.push(mixer);\n  }\n\n  return mixers;\n}\n\nfunction fastInterpolate(_ref3, _ref4) {\n  let [from, to] = _ref3;\n  let [mixer] = _ref4;\n  return v => mixer(progress(from, to, v));\n}\n\nfunction slowInterpolate(input, mixers) {\n  const inputLength = input.length;\n  const lastInputIndex = inputLength - 1;\n  return v => {\n    let mixerIndex = 0;\n    let foundMixerIndex = false;\n\n    if (v <= input[0]) {\n      foundMixerIndex = true;\n    } else if (v >= input[lastInputIndex]) {\n      mixerIndex = lastInputIndex - 1;\n      foundMixerIndex = true;\n    }\n\n    if (!foundMixerIndex) {\n      let i = 1;\n\n      for (; i < inputLength; i++) {\n        if (input[i] > v || i === lastInputIndex) {\n          break;\n        }\n      }\n\n      mixerIndex = i - 1;\n    }\n\n    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n    return mixers[mixerIndex](progressInRange);\n  };\n}\n\nfunction interpolate(input, output) {\n  let {\n    clamp: isClamp = true,\n    ease,\n    mixer\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const inputLength = input.length;\n  heyListen.invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n  heyListen.invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n\n  if (input[0] > input[inputLength - 1]) {\n    input = [].concat(input);\n    output = [].concat(output);\n    input.reverse();\n    output.reverse();\n  }\n\n  const mixers = createMixers(output, ease, mixer);\n  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);\n  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;\n}\n\nconst reverseEasing = easing => p => 1 - easing(1 - p);\n\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nconst createExpoIn = power => p => Math.pow(p, power);\n\nconst createBackIn = power => p => p * p * ((power + 1) * p - power);\n\nconst createAnticipate = power => {\n  const backEasing = createBackIn(power);\n  return p => (p *= 2) < 1 ? 0.5 * backEasing(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\n\nconst linear = p => p;\n\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\n\nconst circIn = p => 1 - Math.sin(Math.acos(p));\n\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\n\nconst bounceOut = p => {\n  if (p === 1 || p === 0) return p;\n  const p2 = p * p;\n  return p < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p2 : p < BOUNCE_SECOND_THRESHOLD ? 9.075 * p2 - 9.9 * p + 3.4 : p < BOUNCE_THIRD_THRESHOLD ? ca * p2 - cb * p + cc : 10.8 * p * p - 20.52 * p + 10.72;\n};\n\nconst bounceIn = reverseEasing(bounceOut);\n\nconst bounceInOut = p => p < 0.5 ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0)) : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\nfunction defaultEasing(values, easing) {\n  return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\n\nfunction defaultOffset(values) {\n  const numValues = values.length;\n  return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\n\nfunction convertOffsetToTimes(offset, duration) {\n  return offset.map(o => o * duration);\n}\n\nfunction keyframes(_ref5) {\n  let {\n    from = 0,\n    to = 1,\n    ease,\n    offset,\n    duration = 300\n  } = _ref5;\n  const state = {\n    done: false,\n    value: from\n  };\n  const values = Array.isArray(to) ? to : [from, to];\n  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);\n\n  function createInterpolator() {\n    return interpolate(times, values, {\n      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)\n    });\n  }\n\n  let interpolator = createInterpolator();\n  return {\n    next: t => {\n      state.value = interpolator(t);\n      state.done = t >= duration;\n      return state;\n    },\n    flipTarget: () => {\n      values.reverse();\n      interpolator = createInterpolator();\n    }\n  };\n}\n\nfunction decay(_ref6) {\n  let {\n    velocity = 0,\n    from = 0,\n    power = 0.8,\n    timeConstant = 350,\n    restDelta = 0.5,\n    modifyTarget\n  } = _ref6;\n  const state = {\n    done: false,\n    value: from\n  };\n  let amplitude = power * velocity;\n  const ideal = from + amplitude;\n  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n  if (target !== ideal) amplitude = target - from;\n  return {\n    next: t => {\n      const delta = -amplitude * Math.exp(-t / timeConstant);\n      state.done = !(delta > restDelta || delta < -restDelta);\n      state.value = state.done ? target : target + delta;\n      return state;\n    },\n    flipTarget: () => {}\n  };\n}\n\nconst types = {\n  keyframes,\n  spring,\n  decay\n};\n\nfunction detectAnimationFromOptions(config) {\n  if (Array.isArray(config.to)) {\n    return keyframes;\n  } else if (types[config.type]) {\n    return types[config.type];\n  }\n\n  const keys = new Set(Object.keys(config));\n\n  if (keys.has(\"ease\") || keys.has(\"duration\") && !keys.has(\"dampingRatio\")) {\n    return keyframes;\n  } else if (keys.has(\"dampingRatio\") || keys.has(\"stiffness\") || keys.has(\"mass\") || keys.has(\"damping\") || keys.has(\"restSpeed\") || keys.has(\"restDelta\")) {\n    return spring;\n  }\n\n  return keyframes;\n}\n\nfunction loopElapsed(elapsed, duration) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return elapsed - duration - delay;\n}\n\nfunction reverseElapsed(elapsed, duration) {\n  let delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let isForwardPlayback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay) : duration - (elapsed - duration) + delay;\n}\n\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n  return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nconst framesync = update => {\n  const passTimestamp = _ref7 => {\n    let {\n      delta\n    } = _ref7;\n    return update(delta);\n  };\n\n  return {\n    start: () => sync__default[\"default\"].update(passTimestamp, true),\n    stop: () => sync.cancelSync.update(passTimestamp)\n  };\n};\n\nfunction animate(_a) {\n  var _b, _c;\n\n  var {\n    from,\n    autoplay = true,\n    driver = framesync,\n    elapsed = 0,\n    repeat: repeatMax = 0,\n    repeatType = \"loop\",\n    repeatDelay = 0,\n    onPlay,\n    onStop,\n    onComplete,\n    onRepeat,\n    onUpdate\n  } = _a,\n      options = tslib.__rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n\n  let {\n    to\n  } = options;\n  let driverControls;\n  let repeatCount = 0;\n  let computedDuration = options.duration;\n  let latest;\n  let isComplete = false;\n  let isForwardPlayback = true;\n  let interpolateFromNumber;\n  const animator = detectAnimationFromOptions(options);\n\n  if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n    interpolateFromNumber = interpolate([0, 100], [from, to], {\n      clamp: false\n    });\n    from = 0;\n    to = 100;\n  }\n\n  const animation = animator(Object.assign(Object.assign({}, options), {\n    from,\n    to\n  }));\n\n  function repeat() {\n    repeatCount++;\n\n    if (repeatType === \"reverse\") {\n      isForwardPlayback = repeatCount % 2 === 0;\n      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n    } else {\n      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n      if (repeatType === \"mirror\") animation.flipTarget();\n    }\n\n    isComplete = false;\n    onRepeat && onRepeat();\n  }\n\n  function complete() {\n    driverControls.stop();\n    onComplete && onComplete();\n  }\n\n  function update(delta) {\n    if (!isForwardPlayback) delta = -delta;\n    elapsed += delta;\n\n    if (!isComplete) {\n      const state = animation.next(Math.max(0, elapsed));\n      latest = state.value;\n      if (interpolateFromNumber) latest = interpolateFromNumber(latest);\n      isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n    }\n\n    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n\n    if (isComplete) {\n      if (repeatCount === 0) computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;\n\n      if (repeatCount < repeatMax) {\n        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n      } else {\n        complete();\n      }\n    }\n  }\n\n  function play() {\n    onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n    driverControls = driver(update);\n    driverControls.start();\n  }\n\n  autoplay && play();\n  return {\n    stop: () => {\n      onStop === null || onStop === void 0 ? void 0 : onStop();\n      driverControls.stop();\n    }\n  };\n}\n\nfunction velocityPerSecond(velocity, frameDuration) {\n  return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nfunction inertia(_ref8) {\n  let {\n    from = 0,\n    velocity = 0,\n    min,\n    max,\n    power = 0.8,\n    timeConstant = 750,\n    bounceStiffness = 500,\n    bounceDamping = 10,\n    restDelta = 1,\n    modifyTarget,\n    driver,\n    onUpdate,\n    onComplete,\n    onStop\n  } = _ref8;\n  let currentAnimation;\n\n  function isOutOfBounds(v) {\n    return min !== undefined && v < min || max !== undefined && v > max;\n  }\n\n  function boundaryNearest(v) {\n    if (min === undefined) return max;\n    if (max === undefined) return min;\n    return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n  }\n\n  function startAnimation(options) {\n    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n    currentAnimation = animate(Object.assign(Object.assign({}, options), {\n      driver,\n      onUpdate: v => {\n        var _a;\n\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n      },\n      onComplete,\n      onStop\n    }));\n  }\n\n  function startSpring(options) {\n    startAnimation(Object.assign({\n      type: \"spring\",\n      stiffness: bounceStiffness,\n      damping: bounceDamping,\n      restDelta\n    }, options));\n  }\n\n  if (isOutOfBounds(from)) {\n    startSpring({\n      from,\n      velocity,\n      to: boundaryNearest(from)\n    });\n  } else {\n    let target = power * velocity + from;\n    if (typeof modifyTarget !== \"undefined\") target = modifyTarget(target);\n    const boundary = boundaryNearest(target);\n    const heading = boundary === min ? -1 : 1;\n    let prev;\n    let current;\n\n    const checkBoundary = v => {\n      prev = current;\n      current = v;\n      velocity = velocityPerSecond(v - prev, sync.getFrameData().delta);\n\n      if (heading === 1 && v > boundary || heading === -1 && v < boundary) {\n        startSpring({\n          from: v,\n          to: boundary,\n          velocity\n        });\n      }\n    };\n\n    startAnimation({\n      type: \"decay\",\n      from,\n      velocity,\n      timeConstant,\n      power,\n      restDelta,\n      modifyTarget,\n      onUpdate: isOutOfBounds(target) ? checkBoundary : undefined\n    });\n  }\n\n  return {\n    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()\n  };\n}\n\nconst radiansToDegrees = radians => radians * 180 / Math.PI;\n\nconst angle = function (a) {\n  let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : zeroPoint;\n  return radiansToDegrees(Math.atan2(b.y - a.y, b.x - a.x));\n};\n\nconst applyOffset = (from, to) => {\n  let hasReceivedFrom = true;\n\n  if (to === undefined) {\n    to = from;\n    hasReceivedFrom = false;\n  }\n\n  return v => {\n    if (hasReceivedFrom) {\n      return v - from + to;\n    } else {\n      from = v;\n      hasReceivedFrom = true;\n      return to;\n    }\n  };\n};\n\nconst identity = v => v;\n\nconst createAttractor = function () {\n  let alterDisplacement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n  return (constant, origin, v) => {\n    const displacement = origin - v;\n    const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));\n    return displacement <= 0 ? origin + springModifiedDisplacement : origin - springModifiedDisplacement;\n  };\n};\n\nconst attract = createAttractor();\nconst attractExpo = createAttractor(Math.sqrt);\n\nconst degreesToRadians = degrees => degrees * Math.PI / 180;\n\nconst isPoint = point => point.hasOwnProperty('x') && point.hasOwnProperty('y');\n\nconst isPoint3D = point => isPoint(point) && point.hasOwnProperty('z');\n\nconst distance1D = (a, b) => Math.abs(a - b);\n\nfunction distance(a, b) {\n  if (isNum(a) && isNum(b)) {\n    return distance1D(a, b);\n  } else if (isPoint(a) && isPoint(b)) {\n    const xDelta = distance1D(a.x, b.x);\n    const yDelta = distance1D(a.y, b.y);\n    const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n  }\n}\n\nconst pointFromVector = (origin, angle, distance) => {\n  angle = degreesToRadians(angle);\n  return {\n    x: distance * Math.cos(angle) + origin.x,\n    y: distance * Math.sin(angle) + origin.y\n  };\n};\n\nconst toDecimal = function (num) {\n  let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  precision = Math.pow(10, precision);\n  return Math.round(num * precision) / precision;\n};\n\nconst smoothFrame = function (prevValue, nextValue, duration) {\n  let smoothing = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  return toDecimal(prevValue + duration * (nextValue - prevValue) / Math.max(smoothing, duration));\n};\n\nconst smooth = function () {\n  let strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n  let previousValue = 0;\n  let lastUpdated = 0;\n  return v => {\n    const currentFramestamp = sync.getFrameData().timestamp;\n    const timeDelta = currentFramestamp !== lastUpdated ? currentFramestamp - lastUpdated : 0;\n    const newValue = timeDelta ? smoothFrame(previousValue, v, timeDelta, strength) : previousValue;\n    lastUpdated = currentFramestamp;\n    previousValue = newValue;\n    return newValue;\n  };\n};\n\nconst snap = points => {\n  if (typeof points === 'number') {\n    return v => Math.round(v / points) * points;\n  } else {\n    let i = 0;\n    const numPoints = points.length;\n    return v => {\n      let lastDistance = Math.abs(points[0] - v);\n\n      for (i = 1; i < numPoints; i++) {\n        const point = points[i];\n        const distance = Math.abs(point - v);\n        if (distance === 0) return point;\n        if (distance > lastDistance) return points[i - 1];\n        if (i === numPoints - 1) return point;\n        lastDistance = distance;\n      }\n    };\n  }\n};\n\nfunction velocityPerFrame(xps, frameDuration) {\n  return xps / (1000 / frameDuration);\n}\n\nconst wrap = (min, max, v) => {\n  const rangeSize = max - min;\n  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;\n};\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\n\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\n\nconst c = a1 => 3.0 * a1;\n\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\n\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n  let currentX;\n  let currentT;\n  let i = 0;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);\n\n  return currentT;\n}\n\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\n\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n  for (let i = 0; i < newtonIterations; ++i) {\n    const currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n  if (mX1 === mY1 && mX2 === mY2) return linear;\n  const sampleValues = new Float32Array(kSplineTableSize);\n\n  for (let i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    let intervalStart = 0.0;\n    let currentSample = 1;\n    const lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample;\n    const dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    const guessForT = intervalStart + dist * kSampleStepSize;\n    const initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= newtonMinSlope) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nconst steps = function (steps) {\n  let direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'end';\n  return progress => {\n    progress = direction === 'end' ? Math.min(progress, 0.999) : Math.max(progress, 0.001);\n    const expanded = progress * steps;\n    const rounded = direction === 'end' ? Math.floor(expanded) : Math.ceil(expanded);\n    return clamp(0, 1, rounded / steps);\n  };\n};\n\nexports.angle = angle;\nexports.animate = animate;\nexports.anticipate = anticipate;\nexports.applyOffset = applyOffset;\nexports.attract = attract;\nexports.attractExpo = attractExpo;\nexports.backIn = backIn;\nexports.backInOut = backInOut;\nexports.backOut = backOut;\nexports.bounceIn = bounceIn;\nexports.bounceInOut = bounceInOut;\nexports.bounceOut = bounceOut;\nexports.circIn = circIn;\nexports.circInOut = circInOut;\nexports.circOut = circOut;\nexports.clamp = clamp;\nexports.createAnticipate = createAnticipate;\nexports.createAttractor = createAttractor;\nexports.createBackIn = createBackIn;\nexports.createExpoIn = createExpoIn;\nexports.cubicBezier = cubicBezier;\nexports.decay = decay;\nexports.degreesToRadians = degreesToRadians;\nexports.distance = distance;\nexports.easeIn = easeIn;\nexports.easeInOut = easeInOut;\nexports.easeOut = easeOut;\nexports.inertia = inertia;\nexports.interpolate = interpolate;\nexports.isPoint = isPoint;\nexports.isPoint3D = isPoint3D;\nexports.keyframes = keyframes;\nexports.linear = linear;\nexports.mirrorEasing = mirrorEasing;\nexports.mix = mix;\nexports.mixColor = mixColor;\nexports.mixComplex = mixComplex;\nexports.pipe = pipe;\nexports.pointFromVector = pointFromVector;\nexports.progress = progress;\nexports.radiansToDegrees = radiansToDegrees;\nexports.reverseEasing = reverseEasing;\nexports.smooth = smooth;\nexports.smoothFrame = smoothFrame;\nexports.snap = snap;\nexports.spring = spring;\nexports.steps = steps;\nexports.toDecimal = toDecimal;\nexports.velocityPerFrame = velocityPerFrame;\nexports.velocityPerSecond = velocityPerSecond;\nexports.wrap = wrap;","map":null,"metadata":{},"sourceType":"script"}